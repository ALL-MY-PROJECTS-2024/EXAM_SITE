{
  "questions": [
    {
      "id": 1,
      "question": "객체지향 프로그래밍의 주요 속성에 해당하지 않는 것은?",
      "choices": ["캡슐화", "추상화", "데이터 흐름", "다형성"],
      "correct_answer": "데이터 흐름",
      "explanation": "객체지향 프로그래밍의 주요 속성은 캡슐화, 추상화, 상속, 다형성입니다. 데이터 흐름은 구조적 프로그래밍에서 주로 다루는 개념입니다.",
      "wrong_answers": {
        "캡슐화": "객체의 속성과 메소드를 하나로 묶고, 외부에서 접근을 제한하는 개념입니다.",
        "추상화": "필요한 속성과 동작만을 노출하고 불필요한 부분을 숨기는 개념입니다.",
        "다형성": "같은 인터페이스나 메소드명이 다양한 방식으로 동작할 수 있도록 하는 개념입니다."
      }
    },
    {
      "id": 2,
      "question": "상속성이란 무엇을 의미하는가?",
      "choices": [
        "하나의 클래스가 다른 클래스의 속성과 기능을 물려받는 것",
        "하나의 메소드가 여러 기능을 수행하는 것",
        "데이터를 외부에 공개하지 않는 것",
        "클래스를 생성하는 것"
      ],
      "correct_answer": "하나의 클래스가 다른 클래스의 속성과 기능을 물려받는 것",
      "explanation": "상속은 객체지향 프로그래밍에서 기존 클래스를 기반으로 새로운 클래스를 생성하는 기능을 의미합니다.",
      "wrong_answers": {
        "하나의 메소드가 여러 기능을 수행하는 것": "이는 다형성의 개념에 해당합니다.",
        "데이터를 외부에 공개하지 않는 것": "이 개념은 캡슐화와 관련이 있습니다.",
        "클래스를 생성하는 것": "클래스 생성은 일반적인 프로그래밍 개념으로, 상속성과 직접적인 관련이 없습니다."
      }
    },
    {
      "id": 3,
      "question": "객체지향 설계 원칙 중 단일 책임 원칙의 의미는 무엇인가?",
      "choices": [
        "클래스는 한 가지 책임만 가져야 한다",
        "클래스는 여러 책임을 분산하여 수행해야 한다",
        "클래스는 외부의 데이터를 보호해야 한다",
        "클래스는 항상 상속을 사용해야 한다"
      ],
      "correct_answer": "클래스는 한 가지 책임만 가져야 한다",
      "explanation": "단일 책임 원칙(SRP, Single Responsibility Principle)은 하나의 클래스가 하나의 책임만을 가져야 함을 의미합니다.",
      "wrong_answers": {
        "클래스는 여러 책임을 분산하여 수행해야 한다": "SRP에서는 한 클래스가 여러 책임을 가지면 유지보수가 어려워지므로 권장되지 않습니다.",
        "클래스는 외부의 데이터를 보호해야 한다": "이것은 캡슐화와 관련된 개념입니다.",
        "클래스는 항상 상속을 사용해야 한다": "객체지향 프로그래밍에서 상속은 선택적인 기법이며, 반드시 사용할 필요는 없습니다."
      }
    },
    {
      "id": 4,
      "question": "객체지향 언어에서 다형성을 구현하는 방법으로 올바른 것은?",
      "choices": [
        "메소드 오버로딩과 오버라이딩",
        "데이터 캡슐화와 은닉화",
        "추상 클래스와 객체 생성",
        "상속과 데이터 보호"
      ],
      "correct_answer": "메소드 오버로딩과 오버라이딩",
      "explanation": "다형성은 메소드 오버로딩(같은 메소드 이름을 여러 개 정의)과 메소드 오버라이딩(부모 클래스의 메소드를 재정의)으로 구현됩니다.",
      "wrong_answers": {
        "데이터 캡슐화와 은닉화": "캡슐화와 은닉화는 데이터 보호와 관련된 개념입니다.",
        "추상 클래스와 객체 생성": "추상 클래스는 다형성의 일부이지만, 다형성 자체를 의미하지는 않습니다.",
        "상속과 데이터 보호": "상속은 다형성과 관련이 있지만, 데이터 보호는 다형성과 직접적인 관련이 없습니다."
      }
    },
    {
      "id": 5,
      "question": "객체지향 프로그래밍에서 클래스와 객체의 관계는 무엇인가?",
      "choices": [
        "클래스는 객체의 복사본이다",
        "클래스는 객체의 설계도이다",
        "객체는 클래스의 부모이다",
        "객체는 데이터만 포함한다"
      ],
      "correct_answer": "클래스는 객체의 설계도이다",
      "explanation": "클래스는 객체를 생성하기 위한 설계도로, 객체는 클래스의 인스턴스(instance)입니다.",
      "wrong_answers": {
        "클래스는 객체의 복사본이다": "클래스는 복사본이 아니라 객체를 정의하는 틀입니다.",
        "객체는 클래스의 부모이다": "객체는 클래스의 인스턴스이며, 부모 개념이 아닙니다.",
        "객체는 데이터만 포함한다": "객체는 데이터뿐만 아니라 메소드(행동)도 포함합니다."
      }
    },
    {
      "id": 6,
      "question": "유스케이스 다이어그램에서 액터는 무엇을 나타내는가?",
      "choices": [
        "시스템 외부와 상호작용하는 요소",
        "데이터 흐름의 방향",
        "클래스 간의 상호 관계",
        "객체의 내부 상태"
      ],
      "correct_answer": "시스템 외부와 상호작용하는 요소",
      "explanation": "유스케이스 다이어그램에서 액터(Actor)는 시스템 외부에서 시스템과 상호작용하는 사용자를 나타냅니다.",
      "wrong_answers": {
        "데이터 흐름의 방향": "데이터 흐름은 DFD(데이터 흐름도)에서 다루는 개념입니다.",
        "클래스 간의 상호 관계": "클래스 간의 관계는 클래스 다이어그램에서 다룹니다.",
        "객체의 내부 상태": "객체의 내부 상태는 객체의 속성으로 정의됩니다."
      }
    },
    {
      "id": 7,
      "question": "객체지향 설계 원칙 중 개방-폐쇄 원칙의 의미는 무엇인가?",
      "choices": [
        "코드는 확장에는 열려 있고 수정에는 닫혀 있어야 한다",
        "모든 데이터는 외부에 공개되어야 한다",
        "상속을 통해 모든 클래스가 수정 가능해야 한다",
        "모든 메소드는 추상화되어야 한다"
      ],
      "correct_answer": "코드는 확장에는 열려 있고 수정에는 닫혀 있어야 한다",
      "explanation": "개방-폐쇄 원칙(OCP, Open-Closed Principle)은 기존 코드를 수정하지 않고 확장이 가능하도록 설계해야 한다는 원칙입니다.",
      "wrong_answers": {
        "모든 데이터는 외부에 공개되어야 한다": "이것은 캡슐화 원칙에 위배됩니다.",
        "상속을 통해 모든 클래스가 수정 가능해야 한다": "클래스를 상속하는 것이 필수는 아닙니다.",
        "모든 메소드는 추상화되어야 한다": "일반 메소드도 필요하며, 모든 메소드를 추상화할 필요는 없습니다."
      }
    },
    {
      "id": 8,
      "question": "다음 중 UML 다이어그램의 종류가 아닌 것은?",
      "choices": [
        "클래스 다이어그램",
        "유스케이스 다이어그램",
        "상태 전이 다이어그램",
        "데이터 흐름 다이어그램"
      ],
      "correct_answer": "데이터 흐름 다이어그램",
      "explanation": "UML 다이어그램에는 클래스 다이어그램, 유스케이스 다이어그램, 상태 전이 다이어그램 등이 포함되지만, 데이터 흐름 다이어그램(DFD)은 UML에 속하지 않습니다.",
      "wrong_answers": {
        "클래스 다이어그램": "클래스 다이어그램은 객체지향 시스템에서 클래스 간의 관계를 시각적으로 표현하는 UML 다이어그램입니다.",
        "유스케이스 다이어그램": "유스케이스 다이어그램은 시스템과 외부 액터(사용자) 간의 상호작용을 표현하는 UML 다이어그램입니다.",
        "상태 전이 다이어그램": "상태 전이 다이어그램은 객체의 상태 변화와 상태 간의 전이 과정을 나타내는 UML 다이어그램입니다."
      }
    },
    {
      "id": 9,
      "question": "다형성을 제공하는 객체지향 언어의 주요 특징은?",
      "choices": [
        "하나의 클래스에서 여러 객체를 생성할 수 있음",
        "동일한 메소드가 다양한 방식으로 동작할 수 있음",
        "모든 데이터가 객체로 표현됨",
        "클래스 간의 관계를 은닉함"
      ],
      "correct_answer": "동일한 메소드가 다양한 방식으로 동작할 수 있음",
      "explanation": "다형성(Polymorphism)은 동일한 메소드나 연산이 다양한 방식으로 동작할 수 있도록 하는 객체지향 프로그래밍의 주요 개념입니다.",
      "wrong_answers": {
        "하나의 클래스에서 여러 객체를 생성할 수 있음": "이것은 객체 지향의 기본적인 개념이지만, 다형성의 특징과는 다릅니다.",
        "모든 데이터가 객체로 표현됨": "이 개념은 객체 지향 언어의 특성이지만, 다형성과 직접적인 관련이 없습니다.",
        "클래스 간의 관계를 은닉함": "클래스 간의 관계 은닉은 캡슐화의 개념과 더 밀접한 관련이 있습니다."
      }
    },
    {
      "id": 10,
      "question": "인터페이스 분리 원칙의 의미는?",
      "choices": [
        "하나의 인터페이스는 단일 기능만 포함해야 한다",
        "여러 인터페이스는 한 클래스에서 사용 가능해야 한다",
        "인터페이스는 다른 클래스에서 상속받아야 한다",
        "모든 인터페이스는 동일한 기능을 제공해야 한다"
      ],
      "correct_answer": "하나의 인터페이스는 단일 기능만 포함해야 한다",
      "explanation": "인터페이스 분리 원칙(ISP, Interface Segregation Principle)은 인터페이스는 단일 기능만 포함하고, 클라이언트가 필요하지 않은 기능을 강요받지 않도록 설계해야 한다는 원칙입니다.",
      "wrong_answers": {
        "여러 인터페이스는 한 클래스에서 사용 가능해야 한다": "여러 인터페이스를 한 클래스에서 사용할 수 있지만, 이는 인터페이스 분리 원칙의 핵심 개념이 아닙니다.",
        "인터페이스는 다른 클래스에서 상속받아야 한다": "인터페이스는 상속이 아니라 구현(implements)됩니다.",
        "모든 인터페이스는 동일한 기능을 제공해야 한다": "인터페이스는 특정 기능을 정의하며, 모든 인터페이스가 동일한 기능을 제공해야 하는 것은 아닙니다."
      }
    },
    {
      "id": 11,
      "question": "객체지향 언어에서 접근 제어자 중 public의 의미는?",
      "choices": [
        "클래스 외부에서 접근이 가능하다",
        "상속받은 클래스만 접근 가능하다",
        "동일한 패키지에서만 접근 가능하다",
        "클래스 내부에서만 접근 가능하다"
      ],
      "correct_answer": "클래스 외부에서 접근이 가능하다",
      "explanation": "public 접근 제어자는 클래스 외부에서도 자유롭게 접근할 수 있도록 허용하는 접근 수준입니다.",
      "wrong_answers": {
        "상속받은 클래스만 접근 가능하다": "이는 protected 접근 제어자의 특징입니다.",
        "동일한 패키지에서만 접근 가능하다": "이는 default 접근 제어자의 특징입니다.",
        "클래스 내부에서만 접근 가능하다": "이는 private 접근 제어자의 특징입니다."
      }
    },
    {
      "id": 12,
      "question": "다음 중 상속 관계를 나타내는 UML 다이어그램의 표기법은?",
      "choices": ["실선 화살표", "점선 화살표", "삼각형 화살표", "사각형 박스"],
      "correct_answer": "삼각형 화살표",
      "explanation": "UML 다이어그램에서 상속 관계는 삼각형 화살표(빈 삼각형)를 사용하여 부모 클래스에서 자식 클래스로의 상속을 나타냅니다.",
      "wrong_answers": {
        "실선 화살표": "일반적으로 객체 간의 연관 관계(Association)를 나타내는 데 사용됩니다.",
        "점선 화살표": "인터페이스 구현 관계를 표현하는 데 사용됩니다.",
        "사각형 박스": "클래스를 나타내는 기본 요소이지만, 상속을 표현하는 표기법은 아닙니다."
      }
    },
    {
      "id": 13,
      "question": "시퀀스 다이어그램에서 활성 객체를 나타내는 요소는?",
      "choices": ["메시지", "라이프라인", "활성 박스", "클래스"],
      "correct_answer": "활성 박스",
      "explanation": "시퀀스 다이어그램에서 활성 박스(Activation Bar)는 객체가 특정 시점에서 활성 상태(즉, 실행 중)임을 나타냅니다.",
      "wrong_answers": {
        "메시지": "객체 간의 메소드 호출이나 이벤트를 나타냅니다.",
        "라이프라인": "객체의 수명 주기를 나타내는 수직선입니다.",
        "클래스": "클래스 다이어그램에서 사용되며, 시퀀스 다이어그램의 요소는 아닙니다."
      }
    },
    {
      "id": 14,
      "question": "추상 클래스와 인터페이스의 차이점은?",
      "choices": [
        "추상 클래스는 객체를 생성할 수 있다",
        "인터페이스는 다중 상속이 가능하다",
        "추상 클래스는 메소드를 가질 수 없다",
        "인터페이스는 상속을 지원하지 않는다"
      ],
      "correct_answer": "인터페이스는 다중 상속이 가능하다",
      "explanation": "인터페이스는 여러 개를 구현(implements)할 수 있어 다중 상속을 허용하는 반면, 추상 클래스는 단일 상속만 가능합니다.",
      "wrong_answers": {
        "추상 클래스는 객체를 생성할 수 있다": "추상 클래스는 직접 객체를 생성할 수 없습니다.",
        "추상 클래스는 메소드를 가질 수 없다": "추상 클래스는 일반 메소드와 추상 메소드를 모두 가질 수 있습니다.",
        "인터페이스는 상속을 지원하지 않는다": "인터페이스도 다른 인터페이스를 상속할 수 있습니다."
      }
    },
    {
      "id": 15,
      "question": "객체지향 언어에서 캡슐화의 주요 목적은?",
      "choices": [
        "객체 간의 데이터 공유",
        "데이터를 외부로부터 보호",
        "클래스 간의 상속 구현",
        "메모리 효율성 증가"
      ],
      "correct_answer": "데이터를 외부로부터 보호",
      "explanation": "캡슐화는 객체 내부의 데이터를 보호하고, 외부에서는 접근을 제한하는 중요한 객체지향 개념입니다.",
      "wrong_answers": {
        "객체 간의 데이터 공유": "캡슐화는 데이터 공유보다는 보호를 목적으로 합니다.",
        "클래스 간의 상속 구현": "상속은 캡슐화와 별개의 객체지향 개념입니다.",
        "메모리 효율성 증가": "캡슐화는 메모리 효율성보다는 데이터 보호와 모듈화를 목표로 합니다."
      }
    }
  ]
}
