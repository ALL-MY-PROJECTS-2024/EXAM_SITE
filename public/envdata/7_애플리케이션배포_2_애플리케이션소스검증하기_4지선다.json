{
  "questions": [
    {
      "id": 1,
      "question": "정적 테스트 도구의 주요 목적은 무엇입니까?",
      "choices": [
        "프로그램의 실행 속도를 높이기 위해",
        "프로그램 실행 중 메모리 사용량을 줄이기 위해",
        "개발 초기 단계에서 결함을 조기에 발견하기 위해",
        "실행 중인 프로그램의 로직 오류를 검증하기 위해"
      ],
      "correct_answer": "개발 초기 단계에서 결함을 조기에 발견하기 위해",
      "explanation": "정적 테스트 도구는 프로그램을 실행하지 않고 코드 분석을 통해 오류를 조기에 발견하는 데 사용된다.",
      "wrong_answers": {
        "프로그램의 실행 속도를 높이기 위해": "정적 테스트 도구는 코드 실행 속도를 직접적으로 향상시키지는 않는다.",
        "프로그램 실행 중 메모리 사용량을 줄이기 위해": "메모리 최적화는 정적 분석보다는 실행 환경과 관련된 최적화 기법에 의존한다.",
        "실행 중인 프로그램의 로직 오류를 검증하기 위해": "로직 오류 검증은 주로 동적 테스트 도구에서 수행된다."
      }
    },
    {
      "id": 2,
      "question": "다음 중 형상관리 시스템의 기능으로 옳지 않은 것은?",
      "choices": [
        "형상항목 변경 점검 및 통제",
        "소스코드 품질 측정",
        "형상항목 버전관리",
        "기준선 설정"
      ],
      "correct_answer": "소스코드 품질 측정",
      "explanation": "형상관리 시스템은 코드 품질을 측정하는 것이 아니라, 형상항목의 변경 내역 관리와 버전 관리를 주된 기능으로 한다.",
      "wrong_answers": {
        "형상항목 변경 점검 및 통제": "형상관리 시스템은 변경 사항을 추적하고 점검하는 역할을 한다.",
        "형상항목 버전관리": "형상관리 시스템의 핵심 기능 중 하나는 소스코드 및 형상항목의 버전 관리이다.",
        "기준선 설정": "형상관리 시스템은 공식적으로 검토된 기준선을 설정하고 유지하는 기능을 포함한다."
      }
    },
    {
      "id": 3,
      "question": "코드 인스펙션의 주된 목적은 무엇입니까?",
      "choices": [
        "프로그램 실행 속도 최적화",
        "작성 규칙 위반 코드 추출",
        "테스트 도구의 오류 검증",
        "빌드 절차 자동화"
      ],
      "correct_answer": "작성 규칙 위반 코드 추출",
      "explanation": "코드 인스펙션은 코드의 스타일과 품질을 분석하여 작성 규칙 위반 사항을 찾아내는 과정이다.",
      "wrong_answers": {
        "프로그램 실행 속도 최적화": "코드 인스펙션은 성능 최적화보다는 코드 품질 유지에 초점을 둔다.",
        "테스트 도구의 오류 검증": "테스트 도구 검증은 코드 인스펙션과는 별개의 과정이다.",
        "빌드 절차 자동화": "빌드 절차 자동화는 CI/CD 도구의 역할이며 코드 인스펙션과는 관련이 없다."
      }
    },
    {
      "id": 4,
      "question": "동적 테스트 도구가 제공하는 주요 이점은 무엇입니까?",
      "choices": [
        "코드 구조의 충분한 테스트 여부 확인",
        "빌드 스크립트의 오류 점검",
        "소스코드의 가독성 향상",
        "테스트 실행 속도 향상"
      ],
      "correct_answer": "코드 구조의 충분한 테스트 여부 확인",
      "explanation": "동적 테스트 도구는 프로그램을 실행하면서 테스트가 충분히 수행되었는지를 확인할 수 있다.",
      "wrong_answers": {
        "빌드 스크립트의 오류 점검": "빌드 스크립트 점검은 빌드 도구의 역할이다.",
        "소스코드의 가독성 향상": "가독성 향상은 정적 코드 분석 도구의 역할에 가깝다.",
        "테스트 실행 속도 향상": "동적 테스트 도구는 테스트 속도를 향상시키는 것이 아니라, 코드의 동작을 검증하는 역할을 한다."
      }
    },
    {
      "id": 5,
      "question": "형상관리 시스템의 '반출'(Check Out) 과정에 대한 설명으로 옳은 것은?",
      "choices": [
        "변경 완료된 소스를 저장소에 저장",
        "형상항목을 변경하기 위해 저장소에서 가져옴",
        "변경된 소스의 버전을 생성",
        "변경 내역에 대한 리뷰를 수행"
      ],
      "correct_answer": "형상항목을 변경하기 위해 저장소에서 가져옴",
      "explanation": "Check Out은 저장소에서 형상항목을 가져와 변경할 수 있도록 하는 과정이다.",
      "wrong_answers": {
        "변경 완료된 소스를 저장소에 저장": "이 과정은 Check In에 해당한다.",
        "변경된 소스의 버전을 생성": "버전 생성은 Check In 또는 Commit 시점에서 이루어진다.",
        "변경 내역에 대한 리뷰를 수행": "리뷰 과정은 코드 리뷰 단계에서 수행되며 Check Out과 직접적인 관련은 없다."
      }
    },
    {
      "id": 6,
      "question": "다음 중 코드 인스펙션 Rule 유형에 포함되지 않는 것은?",
      "choices": [
        "성능 개선",
        "코드 작성 규칙",
        "에러 발생 가능성",
        "배포 속도 최적화"
      ],
      "correct_answer": "배포 속도 최적화",
      "explanation": "코드 인스펙션은 코드 품질을 유지하기 위한 것이며, 배포 속도를 직접적으로 최적화하는 것은 아니다.",
      "wrong_answers": {
        "성능 개선": "코드 인스펙션 규칙 중 성능 개선에 관한 기준이 포함될 수 있다.",
        "코드 작성 규칙": "코드 스타일과 일관성을 유지하기 위해 코드 작성 규칙이 포함된다.",
        "에러 발생 가능성": "에러 발생 가능성을 낮추는 것이 코드 인스펙션의 주요 목적 중 하나이다."
      }
    },
    {
      "id": 7,
      "question": "정규 표현식에서 문자 클래스의 표현 방식은 무엇입니까?",
      "choices": ["[]", "{}", "()", "^$"],
      "correct_answer": "[]",
      "explanation": "문자 클래스는 대괄호([])를 사용하여 특정 문자 집합을 정의할 때 사용된다.",
      "wrong_answers": {
        "{}": "중괄호는 반복 횟수를 지정할 때 사용된다.",
        "()": "괄호는 그룹을 지정하는 데 사용된다.",
        "^$": "캐럿(^)과 달러($)는 문자열의 시작과 끝을 의미한다."
      }
    },
    {
      "id": 8,
      "question": "코드 인스펙션 결과에서 위반 사항 중 'Critical'의 의미는 무엇입니까?",
      "choices": [
        "에러 발생 가능성이 매우 높은 사항",
        "에러 발생 가능성이 높은 심각한 위반 사항",
        "수정을 권고하는 중요 위반 사항",
        "단순 가독성 개선을 위한 정보 제공"
      ],
      "correct_answer": "에러 발생 가능성이 높은 심각한 위반 사항",
      "explanation": "'Critical'은 코드 오류가 발생할 가능성이 높고 즉각적인 수정이 필요한 심각한 문제를 의미한다.",
      "wrong_answers": {
        "에러 발생 가능성이 매우 높은 사항": "에러 발생 가능성이 높을 수는 있지만, 'Critical'은 반드시 즉각적인 수정이 필요한 심각한 문제를 뜻한다.",
        "수정을 권고하는 중요 위반 사항": "수정을 권고하는 수준의 위반 사항은 'Major' 또는 'Minor' 카테고리에 포함될 수 있다.",
        "단순 가독성 개선을 위한 정보 제공": "'Critical' 위반 사항은 가독성과는 별개로 프로그램 오류를 유발할 가능성이 높은 문제를 의미한다."
      }
    },
    {
      "id": 9,
      "question": "테스트 프레임워크의 구성 요소에 포함되지 않는 것은?",
      "choices": [
        "테스트 코드",
        "테스트 저장소",
        "빌드 스케줄러",
        "테스트 결과 관리"
      ],
      "correct_answer": "빌드 스케줄러",
      "explanation": "빌드 스케줄러는 테스트 프레임워크의 구성 요소가 아니라 CI/CD 시스템에서 사용되는 도구이다.",
      "wrong_answers": {
        "테스트 코드": "테스트 코드(Test Code)는 테스트 프레임워크에서 핵심적인 요소로, 소프트웨어의 특정 기능을 검증하기 위해 작성된다.",
        "테스트 저장소": "테스트 저장소(Test Repository)는 테스트 케이스 및 테스트 데이터를 관리하는 공간으로, 테스트 프레임워크의 필수 요소 중 하나이다.",
        "테스트 결과 관리": "테스트 결과 관리는 테스트 실행 후 생성된 결과를 분석하고 저장하는 기능으로, 테스트 프레임워크에서 중요한 역할을 한다."
      }
    },
    {
      "id": 10,
      "question": "JUnit에서 제공하는 함수 중 배열 a와 b의 일치 여부를 확인하는 함수는 무엇입니까?",
      "choices": [
        "assertTrue(a)",
        "assertArrayEquals(a, b)",
        "assertEquals(a, b)",
        "assertNotNull(a)"
      ],
      "correct_answer": "assertArrayEquals(a, b)",
      "explanation": "assertArrayEquals(a, b)는 두 배열의 요소가 동일한지를 비교하는 JUnit 함수이다.",
      "wrong_answers": {
        "assertTrue(a)": "assertTrue(a)는 조건식이 참인지 확인하는 함수로, 배열 비교와는 관련이 없다.",
        "assertEquals(a, b)": "assertEquals(a, b)는 객체 또는 기본 타입의 값이 동일한지 확인하는 함수로, 배열 비교에는 사용되지 않는다.",
        "assertNotNull(a)": "assertNotNull(a)는 특정 객체가 null이 아닌지 확인하는 함수로, 배열 비교와는 무관하다."
      }
    },
    {
      "id": 11,
      "question": "형상관리 시스템에서 '기준선'(Baseline)의 정의는 무엇입니까?",
      "choices": [
        "형상항목 변경 이력",
        "형상관리 활동의 절차",
        "공식 검토 및 협의된 형상항목 집합체",
        "형상항목의 보안 정책"
      ],
      "correct_answer": "공식 검토 및 협의된 형상항목 집합체",
      "explanation": "기준선(Baseline)은 공식적으로 검토 및 승인된 형상항목의 집합으로, 이후 변경을 관리하는 기준이 된다.",
      "wrong_answers": {
        "형상항목 변경 이력": "기준선은 변경 이력이 아니라 특정 시점에서 승인된 형상항목의 집합이다.",
        "형상관리 활동의 절차": "형상관리 활동의 절차는 기준선과는 별개의 개념이다.",
        "형상항목의 보안 정책": "보안 정책은 형상관리 시스템에서 다룰 수 있으나 기준선의 정의와는 관련이 없다."
      }
    },
    {
      "id": 12,
      "question": "다음 중 테스트 커버리지의 측정 유형이 아닌 것은?",
      "choices": [
        "라인 커버리지",
        "분기 커버리지",
        "조건 커버리지",
        "메서드 커버리지"
      ],
      "correct_answer": "메서드 커버리지",
      "explanation": "테스트 커버리지는 코드의 실행 범위를 측정하는 기준으로 라인 커버리지, 분기 커버리지, 조건 커버리지가 포함되지만, 메서드 커버리지는 일반적인 테스트 커버리지 유형이 아니다.",
      "wrong_answers": {
        "라인 커버리지": "라인 커버리지는 실행된 코드 줄(line)의 비율을 측정하는 방법이다.",
        "분기 커버리지": "분기 커버리지는 프로그램의 분기(조건문, 루프 등)가 실행된 비율을 측정한다.",
        "조건 커버리지": "조건 커버리지는 개별 조건식이 참과 거짓으로 평가되는지를 측정하는 방식이다."
      }
    },
    {
      "id": 13,
      "question": "코드 인스펙션 수행 절차에 포함되지 않는 단계는?",
      "choices": [
        "점검 Rule 정의",
        "점검 결과 검증",
        "반출 의뢰서 작성",
        "배포 스크립트 작성"
      ],
      "correct_answer": "배포 스크립트 작성",
      "explanation": "코드 인스펙션 과정에는 코드 품질 점검과 관련된 활동이 포함되지만, 배포 스크립트 작성은 배포 단계에서 수행된다.",
      "wrong_answers": {
        "점검 Rule 정의": "점검 Rule은 코드 인스펙션에서 위반 사항을 확인하는 기준을 설정하는 과정이다.",
        "점검 결과 검증": "검출된 위반 사항이 올바른지 확인하는 과정으로, 코드 인스펙션에서 필수적인 단계이다.",
        "반출 의뢰서 작성": "반출(Check Out) 과정에서 코드 인스펙션을 요청하기 위해 작성될 수 있는 문서이다."
      }
    },
    {
      "id": 14,
      "question": "소스코드 검증 시 '정보성'(Info.)으로 분류된 위반 사항의 처리 방식은?",
      "choices": [
        "반드시 수정해야 함",
        "개발자가 참고하여 선택적으로 적용",
        "개발 팀장 승인을 받아야 수정 가능",
        "시스템 관리자가 점검 수행"
      ],
      "correct_answer": "개발자가 참고하여 선택적으로 적용",
      "explanation": "'정보성'(Info.) 위반 사항은 필수 수정이 아닌 권고 사항으로, 개발자가 필요에 따라 적용할 수 있다.",
      "wrong_answers": {
        "반드시 수정해야 함": "Critical, Major 위반 사항과 달리 정보성 위반 사항은 필수 수정 대상이 아니다.",
        "개발 팀장 승인을 받아야 수정 가능": "정보성 위반 사항은 팀장 승인 없이 개발자가 자율적으로 적용할 수 있다.",
        "시스템 관리자가 점검 수행": "코드 검증은 주로 개발자가 수행하며, 시스템 관리자의 역할은 아니다."
      }
    },
    {
      "id": 15,
      "question": "테스트 프레임워크의 주요 목적은 무엇입니까?",
      "choices": [
        "프로그램 실행 속도 향상",
        "반복적인 테스트 작업의 자동화",
        "배포 프로세스 단축",
        "코드 작성 규칙 준수"
      ],
      "correct_answer": "반복적인 테스트 작업의 자동화",
      "explanation": "테스트 프레임워크는 단위 테스트 및 통합 테스트를 자동화하여 개발자가 반복적인 테스트를 쉽게 수행할 수 있도록 돕는다.",
      "wrong_answers": {
        "프로그램 실행 속도 향상": "테스트 프레임워크는 코드 실행 속도를 향상시키는 것이 아니라 테스트 과정을 자동화하는 역할을 한다.",
        "배포 프로세스 단축": "배포 프로세스 단축은 CI/CD 도구의 역할이며, 테스트 프레임워크의 주요 목적은 아니다.",
        "코드 작성 규칙 준수": "코드 작성 규칙 준수는 정적 분석 도구의 역할이며, 테스트 프레임워크의 목적과는 다르다."
      }
    }
  ]
}
